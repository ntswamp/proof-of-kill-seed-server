package main

import (
	"app/src/constant"
	lib_db "app/src/lib/db"
	lib_error "app/src/lib/error"
	"app/src/model"
	"context"
	"time"

	ethereum_watcher "github.com/HydroProtocol/ethereum-watcher"
	"github.com/HydroProtocol/ethereum-watcher/blockchain"
	"github.com/onrik/ethrpc"
	"github.com/sirupsen/logrus"
)

func main() {
	apikey := constant.INFURA_TESTNET
	contractId := "0xdca6c45cf522427577e03f08d9bc69c4a62f3ae7"
	//constant.OPENSEA_CONTRACTID_TESTNET
	rpc := ethrpc.New(apikey)

	// Transfer Event
	topicsInterestedIn := []string{"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"}

	handler := func(from, to int, receiptLogs []blockchain.IReceiptLog, isUpToHighestBlock bool) error {
		logrus.Infof("Transfer detected: %d, %d -> %d", len(receiptLogs), from, to)
		var err error
		for _, log := range receiptLogs {
			hash := log.GetTransactionHash()
			topic := log.GetTopics()
			logrus.Infof("Tx Hash: %s, Address: %s\nData: %s, Topic:%s", hash, log.GetAddress(), log.GetData(), topic)

			tx, err := rpc.EthGetTransactionByHash(hash)
			if err != nil {
				return lib_error.WrapError(err)
			}
			logrus.Infof("From ETH Acount: %s", tx.From)

			//write to db
			record := &model.PuzzleSaleTransaction{
				BuyerEthAccount: tx.From,
				PuzzleTokenId:   topic[3],
				TxHash:          hash,
				CreatedAt:       time.Now(),
			}
			client, err := lib_db.Connect(constant.DbIdolverse, nil)
			if err != nil {
				return lib_error.WrapError(err)
			}

			client.StartTransaction()

			modelMgr := client.GetModelManager()

			err = modelMgr.CachedSave(record, nil)
			if err != nil {
				return lib_error.WrapError(err)
			}
			err = modelMgr.WriteAll()
			if err != nil {
				return lib_error.WrapError(err)
			}
			err = client.CommitTransaction()
			if err != nil {
				return lib_error.WrapError(err)
			}

			client.RollbackTransaction()
			client.Close()
		}
		if err != nil {
			return lib_error.WrapError(err)
		}
		return err
	}

	// query for USDT Transfer Events
	receiptLogWatcher := ethereum_watcher.NewReceiptLogWatcher(
		context.TODO(),
		apikey,
		-1,
		contractId,
		topicsInterestedIn,
		handler,
		ethereum_watcher.ReceiptLogWatcherConfig{
			StepSizeForBigLag:               5,
			IntervalForPollingNewBlockInSec: 5,
			RPCMaxRetry:                     3,
			ReturnForBlockWithNoReceiptLog:  true,
		},
	)

	receiptLogWatcher.Run()
}
